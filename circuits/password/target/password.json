{"noir_version":"0.30.0+af57471035e4fa7eaffa71693219df6d029dbcde","hash":16037011054400087190,"abi":{"parameters":[{"name":"preimage","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"},{"name":"password_hash","type":{"kind":"field"},"visibility":"public"},{"name":"salt","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"commitment_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"}],"param_witnesses":{"commitment_hash":[{"start":43,"end":75}],"password_hash":[{"start":10,"end":11}],"preimage":[{"start":0,"end":10}],"salt":[{"start":11,"end":43}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"H4sIAAAAAAAA/62U2U7CUBiEi7jvIrLvO7i1tIXWBUFckZeQCO//BMZOmMQ6F97oSU4+vjaU0H/ORIzlmgZ7zM+RYEeDvRPszZDviu+J74sfiB+KH4nHxI/F4+In4gnxpHhKPC2eEc+K58Tz4gXxonhJvCxeEa+K18Tr4g3xpnhLvC3eET8VPxM/F78QvxQ3xS3xrrgt7oi74j3xvrgn7otfiV+L34jfig/E78SH4iPxe/Gx+IP4o/iT+LP4i/ir+CTkW8HeNr7XJ6+DK2SUXCXXyHVyg9wkt0ist9DvlEPXcH+H3CX3yH3ygDwkj8gYeUzGyRMyQSbJFJkmM2SWzJF5skAWyRJZJitklayRdbJBNskW2SY7ofczNX6uFXJI2mbPceb97tyyrXez688813TcWc+zPMv13I+uZ9tzz/H6/szvm77l2HNr4fr2wlyu7dCzzL8ta/p/zzKRiVU+K5y/CN9BlPeRNeQMGUO+kKNR6HvIEPKD7CA3yAzygqzEmJE4s5FgJlLMQoYZyHH2Bc68xFlXOOMaZ9vgTFucJeaI7kRfoiPRi+hC9B86Dz2HbkOfocPQW+gq9BM6CT2E7kHfoGMGxrJLhvyP6Al0A/oAHYBzj7OO840zPTF+WV+fQIfw8QcAAA==","debug_symbols":"pZDdCsMgDEbfJdde1P7E1lcZZdjWDkG0VDsY4rtPt3YM1rvd5UtODiQBJjlst6sys3XALwG0HYVX1qQUAOtXzy3C5Oi8WD3wsqoISDOlClkkMCstgdcYyQ9KKWM7S0vafOCyiz0BbM70DWv3FSy6v/R4pkc89Kxov/V9CnexKjFoma/Ps82MxzNS9I/lPUnsEw==","file_map":{"29":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, N> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n","path":"std/hash.nr"},"46":{"source":"use dep::std;\n\nfn main(\n    preimage: [Field;10],\n    password_hash: pub Field,\n    salt: pub [u8;32], \n    commitment_hash: pub [u8;32]\n) {\n    // let h = std::hash::keccak256(preimage, 10);\n    let copmputed_innter_password_hash = std::hash::pedersen_hash(preimage);\n    // std::println(copmputed_innter_password_hash);\n\n    // todo: rename input to inner_password_hash_with_salt\n    let mut input: [Field; 33] = [0; 33];\n    input[0] = copmputed_innter_password_hash;\n    for i in 0..32 {\n        input[i + 1] = salt[i] as Field;    \n    }\n\n    let copmputed_password_hash = std::hash::pedersen_hash(input);\n    // std::println(copmputed_password_hash);\n    assert(copmputed_password_hash == password_hash);\n}\n\n#[test]\nfn test_main() {\n    // \n    let preimage: [Field; 10] = [116, 101, 115, 116, 0, 0, 0, 0, 0, 0]; // preimage == \"test\"\n    let password_hash: Field = 0x1520b34fabf874ab7605f4690e7c36a673c511b7dfc2b64941113a82aab117a5;\n    \n    // salt = chain id for test\n    let salt: [u8;32] = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0,\n        // 0, 0, 0, 122, 105 // local\n        0, 0, 170, 54, 167 // sepoliia\n    ]; \n\n    let commitment_hash: [u8;32] = [\n        135, 197,  57, 225, 58, 211, 248,  26,\n        224,  27, 100,  27, 55, 170,  29, 241,\n        169, 191,  63, 118, 94,   8, 209, 198,\n        157, 254, 249,  95, 78,  14,  34,  39\n    ];\n    \n    main(preimage, password_hash, salt, commitment_hash);\n\n    // copmputed_password_hash: 0x16e1253d322e880f7431ece012507afb4638b74156c8bd99bb37d08a170d9887\n}","path":"/Users/jack-sw/Codes/brussels/mfa-multisig/circuits/password/src/main.nr"}},"names":["main"]}