{"noir_version":"0.30.0+af57471035e4fa7eaffa71693219df6d029dbcde","hash":1430359118073617602,"abi":{"parameters":[{"name":"owner_hash","type":{"kind":"field"},"visibility":"public"},{"name":"hashed_message","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"pub_key","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"param_witnesses":{"hashed_message":[{"start":1,"end":33}],"owner_hash":[{"start":0,"end":1}],"pub_key":[{"start":33,"end":97}],"signature":[{"start":97,"end":161}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"29":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, N> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n","path":"std/hash.nr"},"46":{"source":"use dep::std;\nuse dep::ecrecover;\n\nfn main(\n    owner_hash: pub Field,\n    // domain_separator: pub [u8;32],\n    hashed_message: pub [u8; 32],\n    pub_key: [u8; 64], \n    signature: [u8; 64], \n) {\n    let key = ecrecover::secp256k1::PubKey::from_unified(pub_key);\n\n    let recovered_addr = ecrecover::ecrecover(\n        key.pub_x, \n        key.pub_y,\n        signature,\n        hashed_message\n    );\n\n    // std::println(recovered_addr);\n\n    // let mut input: [Field; 33] = [0; 33];\n    // input[0] = recovered_addr;\n    // for i in 0..32 {\n    //     input[i + 1] = domain_separator[i] as Field;\n    // }\n\n    // let computed_hash = std::hash::pedersen_hash(input);\n    let computed_hash = std::hash::pedersen_hash([recovered_addr]);\n    // std::println(computed_hash);\n    // std::println(owner_hash);\n\n    assert(computed_hash == owner_hash);\n}\n\n#[test]\nfn test_main() {\n\n  let hashed_message = [\n  162,  11, 221, 82, 101,  38, 145, 153,\n  143, 140, 164, 97, 148, 164,  55, 133,\n   17,  93, 198, 63, 125, 169, 147,  53,\n  229, 221,  91, 27,   2, 153, 104, 166\n  ];\n\n  // slice(1, 65)\n  let pub_key = [\n   30, 208, 241, 215, 103,  94, 254, 117,  70, 152,\n   81, 205,  82, 148,   1, 169, 164,  67,  60,   5,  20,\n  174, 250, 221, 242,  79,   1,  65, 210,  85, 102, 168,\n  120, 138,  73, 199,  27, 230, 199, 139,  88,  30, 223,\n  222, 101,  80, 215, 183, 206, 127,  56, 111,  54,  82,\n   44, 173,  86,  64, 143, 202,   3, 123,  35,   7\n  ];\n\n  let owner_hash = 0x137ad2247d8e089ca5dc03f9a70e5bc68392ac2916495968a80c35582c1a3c37;\n//  let owner_hash = 0x0ee869caf0f6187c861a3a319899bb97d0477722d2bce78c99012dc1ae6d729e;\n//   let domain_separator: [u8;32] = [\n//     104, 180, 171,  96, 220, 243, 144,  50,\n//     0, 243, 196,  36, 122, 173, 193, 146,\n//     6, 179,  23,  80, 130, 243,  86, 120,\n//     244, 174, 100, 147, 213,  51, 243, 148\n//   ]; \n\n    \n  let signature = [\n   25,  83, 188,  15,  31, 138, 125,  61,  75, 210,  21,\n  189, 152,   0,  92, 131, 218, 172,  94, 192, 193, 134,\n  157, 109, 196, 152, 210, 247, 229, 218,  78, 217,  93,\n  135, 208,  54, 203, 151, 127,  76, 197, 189,  92,   5,\n  141, 185,  59, 102, 220, 138, 219, 235,  91, 108, 193,\n  227,  61, 200,  57, 163, 137,  92,  36, 209\n  ];\n\n//   main(owner_hash, domain_separator,hashed_message, pub_key, signature);\n main(owner_hash,hashed_message, pub_key, signature);\n}\n\n\n// #[test]\n// fn test_main2() {\n    \n// let owner_hash = 0x04aa9bc66094f8ee4a59cef0b0b99cb9297da9d28f1c1414b7f5a3eeb1720366let\n// domain_separator = [0x00000000000000000000000000000000000000000000000000000000000000bc, 0x00000000000000000000000000000000000000000000000000000000000000b8, 0x0000000000000000000000000000000000000000000000000000000000000064, 0x00000000000000000000000000000000000000000000000000000000000000b0, 0x00000000000000000000000000000000000000000000000000000000000000ee, 0x0000000000000000000000000000000000000000000000000000000000000024, 0x00000000000000000000000000000000000000000000000000000000000000f7, 0x00000000000000000000000000000000000000000000000000000000000000f5, 0x00000000000000000000000000000000000000000000000000000000000000fc, 0x0000000000000000000000000000000000000000000000000000000000000072, 0x00000000000000000000000000000000000000000000000000000000000000ce, 0x00000000000000000000000000000000000000000000000000000000000000cf, 0x00000000000000000000000000000000000000000000000000000000000000f9, 0x00000000000000000000000000000000000000000000000000000000000000ac, 0x000000000000000000000000000000000000000000000000000000000000007f, 0x000000000000000000000000000000000000000000000000000000000000009e, 0x00000000000000000000000000000000000000000000000000000000000000a5, 0x00000000000000000000000000000000000000000000000000000000000000b2, 0x00000000000000000000000000000000000000000000000000000000000000fd, 0x0000000000000000000000000000000000000000000000000000000000000058, 0x00000000000000000000000000000000000000000000000000000000000000b3, 0x000000000000000000000000000000000000000000000000000000000000003c, 0x0000000000000000000000000000000000000000000000000000000000000050, 0x0000000000000000000000000000000000000000000000000000000000000032, 0x00000000000000000000000000000000000000000000000000000000000000b5, 0x000000000000000000000000000000000000000000000000000000000000003a, 0x000000000000000000000000000000000000000000000000000000000000009c, 0x0000000000000000000000000000000000000000000000000000000000000017, 0x00000000000000000000000000000000000000000000000000000000000000b4, 0x00000000000000000000000000000000000000000000000000000000000000ed, 0x000000000000000000000000000000000000000000000000000000000000001f, 0x0000000000000000000000000000000000000000000000000000000000000091]\n// hashed_message = [0x0000000000000000000000000000000000000000000000000000000000000091, 0x00000000000000000000000000000000000000000000000000000000000000ab, 0x0000000000000000000000000000000000000000000000000000000000000097, 0x00000000000000000000000000000000000000000000000000000000000000ad, 0x000000000000000000000000000000000000000000000000000000000000002c, 0x0000000000000000000000000000000000000000000000000000000000000009, 0x0000000000000000000000000000000000000000000000000000000000000031, 0x00000000000000000000000000000000000000000000000000000000000000d0, 0x00000000000000000000000000000000000000000000000000000000000000f7, 0x00000000000000000000000000000000000000000000000000000000000000ca, 0x0000000000000000000000000000000000000000000000000000000000000011, 0x00000000000000000000000000000000000000000000000000000000000000bf, 0x000000000000000000000000000000000000000000000000000000000000003d, 0x00000000000000000000000000000000000000000000000000000000000000f9, 0x0000000000000000000000000000000000000000000000000000000000000033, 0x0000000000000000000000000000000000000000000000000000000000000074, 0x0000000000000000000000000000000000000000000000000000000000000003, 0x0000000000000000000000000000000000000000000000000000000000000042, 0x0000000000000000000000000000000000000000000000000000000000000013, 0x0000000000000000000000000000000000000000000000000000000000000057, 0x0000000000000000000000000000000000000000000000000000000000000037, 0x0000000000000000000000000000000000000000000000000000000000000046, 0x0000000000000000000000000000000000000000000000000000000000000089, 0x0000000000000000000000000000000000000000000000000000000000000035, 0x00000000000000000000000000000000000000000000000000000000000000c7, 0x000000000000000000000000000000000000000000000000000000000000005c, 0x00000000000000000000000000000000000000000000000000000000000000c6, 0x00000000000000000000000000000000000000000000000000000000000000fc, 0x000000000000000000000000000000000000000000000000000000000000004d, 0x00000000000000000000000000000000000000000000000000000000000000cd, 0x000000000000000000000000000000000000000000000000000000000000007c, 0x00000000000000000000000000000000000000000000000000000000000000a6]\n// pub_key = [0x000000000000000000000000000000000000000000000000000000000000001e, 0x00000000000000000000000000000000000000000000000000000000000000d0, 0x00000000000000000000000000000000000000000000000000000000000000f1, 0x00000000000000000000000000000000000000000000000000000000000000d7, 0x0000000000000000000000000000000000000000000000000000000000000067, 0x000000000000000000000000000000000000000000000000000000000000005e, 0x00000000000000000000000000000000000000000000000000000000000000fe, 0x0000000000000000000000000000000000000000000000000000000000000075, 0x0000000000000000000000000000000000000000000000000000000000000046, 0x0000000000000000000000000000000000000000000000000000000000000098, 0x0000000000000000000000000000000000000000000000000000000000000051, 0x00000000000000000000000000000000000000000000000000000000000000cd, 0x0000000000000000000000000000000000000000000000000000000000000052, 0x0000000000000000000000000000000000000000000000000000000000000094, 0x0000000000000000000000000000000000000000000000000000000000000001, 0x00000000000000000000000000000000000000000000000000000000000000a9, 0x00000000000000000000000000000000000000000000000000000000000000a4, 0x0000000000000000000000000000000000000000000000000000000000000043, 0x000000000000000000000000000000000000000000000000000000000000003c, 0x0000000000000000000000000000000000000000000000000000000000000005, 0x0000000000000000000000000000000000000000000000000000000000000014, 0x00000000000000000000000000000000000000000000000000000000000000ae, 0x00000000000000000000000000000000000000000000000000000000000000fa, 0x00000000000000000000000000000000000000000000000000000000000000dd, 0x00000000000000000000000000000000000000000000000000000000000000f2, 0x000000000000000000000000000000000000000000000000000000000000004f, 0x0000000000000000000000000000000000000000000000000000000000000001, 0x0000000000000000000000000000000000000000000000000000000000000041, 0x00000000000000000000000000000000000000000000000000000000000000d2, 0x0000000000000000000000000000000000000000000000000000000000000055, 0x0000000000000000000000000000000000000000000000000000000000000066, 0x00000000000000000000000000000000000000000000000000000000000000a8, 0x0000000000000000000000000000000000000000000000000000000000000078, 0x000000000000000000000000000000000000000000000000000000000000008a, 0x0000000000000000000000000000000000000000000000000000000000000049, 0x00000000000000000000000000000000000000000000000000000000000000c7, 0x000000000000000000000000000000000000000000000000000000000000001b, 0x00000000000000000000000000000000000000000000000000000000000000e6, 0x00000000000000000000000000000000000000000000000000000000000000c7, 0x000000000000000000000000000000000000000000000000000000000000008b, 0x0000000000000000000000000000000000000000000000000000000000000058, 0x000000000000000000000000000000000000000000000000000000000000001e, 0x00000000000000000000000000000000000000000000000000000000000000df, 0x00000000000000000000000000000000000000000000000000000000000000de, 0x0000000000000000000000000000000000000000000000000000000000000065, 0x0000000000000000000000000000000000000000000000000000000000000050, 0x00000000000000000000000000000000000000000000000000000000000000d7, 0x00000000000000000000000000000000000000000000000000000000000000b7, 0x00000000000000000000000000000000000000000000000000000000000000ce, 0x000000000000000000000000000000000000000000000000000000000000007f, 0x0000000000000000000000000000000000000000000000000000000000000038, 0x000000000000000000000000000000000000000000000000000000000000006f, 0x0000000000000000000000000000000000000000000000000000000000000036, 0x0000000000000000000000000000000000000000000000000000000000000052, 0x000000000000000000000000000000000000000000000000000000000000002c, 0x00000000000000000000000000000000000000000000000000000000000000ad, 0x0000000000000000000000000000000000000000000000000000000000000056, 0x0000000000000000000000000000000000000000000000000000000000000040, 0x000000000000000000000000000000000000000000000000000000000000008f, 0x00000000000000000000000000000000000000000000000000000000000000ca, 0x0000000000000000000000000000000000000000000000000000000000000003, 0x000000000000000000000000000000000000000000000000000000000000007b, 0x0000000000000000000000000000000000000000000000000000000000000023, 0x0000000000000000000000000000000000000000000000000000000000000007]\n// signature = [0x00000000000000000000000000000000000000000000000000000000000000f0, 0x00000000000000000000000000000000000000000000000000000000000000f1, 0x0000000000000000000000000000000000000000000000000000000000000040, 0x0000000000000000000000000000000000000000000000000000000000000075, 0x000000000000000000000000000000000000000000000000000000000000005c, 0x00000000000000000000000000000000000000000000000000000000000000db, 0x000000000000000000000000000000000000000000000000000000000000009a, 0x0000000000000000000000000000000000000000000000000000000000000075, 0x00000000000000000000000000000000000000000000000000000000000000d1, 0x0000000000000000000000000000000000000000000000000000000000000096, 0x0000000000000000000000000000000000000000000000000000000000000037, 0x00000000000000000000000000000000000000000000000000000000000000e1, 0x00000000000000000000000000000000000000000000000000000000000000f5, 0x000000000000000000000000000000000000000000000000000000000000007e, 0x0000000000000000000000000000000000000000000000000000000000000040, 0x0000000000000000000000000000000000000000000000000000000000000015, 0x000000000000000000000000000000000000000000000000000000000000003e, 0x000000000000000000000000000000000000000000000000000000000000000c, 0x000000000000000000000000000000000000000000000000000000000000005b, 0x000000000000000000000000000000000000000000000000000000000000009c, 0x0000000000000000000000000000000000000000000000000000000000000050, 0x00000000000000000000000000000000000000000000000000000000000000fb, 0x0000000000000000000000000000000000000000000000000000000000000059, 0x00000000000000000000000000000000000000000000000000000000000000b4, 0x00000000000000000000000000000000000000000000000000000000000000e9, 0x0000000000000000000000000000000000000000000000000000000000000035, 0x00000000000000000000000000000000000000000000000000000000000000a3, 0x000000000000000000000000000000000000000000000000000000000000003a, 0x0000000000000000000000000000000000000000000000000000000000000034, 0x000000000000000000000000000000000000000000000000000000000000004e, 0x00000000000000000000000000000000000000000000000000000000000000a0, 0x0000000000000000000000000000000000000000000000000000000000000006, 0x000000000000000000000000000000000000000000000000000000000000003b, 0x0000000000000000000000000000000000000000000000000000000000000086, 0x000000000000000000000000000000000000000000000000000000000000009e, 0x000000000000000000000000000000000000000000000000000000000000000b, 0x000000000000000000000000000000000000000000000000000000000000008f, 0x000000000000000000000000000000000000000000000000000000000000005f, 0x000000000000000000000000000000000000000000000000000000000000005b, 0x00000000000000000000000000000000000000000000000000000000000000b6, 0x000000000000000000000000000000000000000000000000000000000000008c, 0x000000000000000000000000000000000000000000000000000000000000006e, 0x00000000000000000000000000000000000000000000000000000000000000f0, 0x0000000000000000000000000000000000000000000000000000000000000038, 0x00000000000000000000000000000000000000000000000000000000000000d9, 0x000000000000000000000000000000000000000000000000000000000000003d, 0x0000000000000000000000000000000000000000000000000000000000000085, 0x000000000000000000000000000000000000000000000000000000000000005b, 0x000000000000000000000000000000000000000000000000000000000000001b, 0x00000000000000000000000000000000000000000000000000000000000000ef, 0x000000000000000000000000000000000000000000000000000000000000009d, 0x0000000000000000000000000000000000000000000000000000000000000095, 0x0000000000000000000000000000000000000000000000000000000000000029, 0x00000000000000000000000000000000000000000000000000000000000000c2, 0x0000000000000000000000000000000000000000000000000000000000000044, 0x000000000000000000000000000000000000000000000000000000000000000a, 0x00000000000000000000000000000000000000000000000000000000000000ef, 0x00000000000000000000000000000000000000000000000000000000000000d5, 0x00000000000000000000000000000000000000000000000000000000000000ca, 0x000000000000000000000000000000000000000000000000000000000000000c, 0x000000000000000000000000000000000000000000000000000000000000009f, 0x00000000000000000000000000000000000000000000000000000000000000ff, 0x000000000000000000000000000000000000000000000000000000000000002e, 0x000000000000000000000000000000000000000000000000000000000000002f]\n// }","path":"/Users/jack-sw/Codes/brussels/mfa-multisig/circuits/k256/src/main.nr"},"47":{"source":"use dep::std;\n\nmod secp256k1;\n\nfn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> pub Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [\n        131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117\n    ];\n    let pub_key_y = [\n        53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165\n    ];\n    let signature = [\n        57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177\n    ];\n    let hashed_message = [\n        13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102\n    ];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/Users/jack-sw/nargo/github.com/porco-rosso-j/ecrecover-noir/main/src/lib.nr"},"48":{"source":"use dep::std;\n\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nunconstrained\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        // let (key_x, key_y) = array_helpers::split_u8_64_unconstrained(pub_key);\n         let (key_x, key_y) = split_u8_64_unconstrained(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    fn to_eth_address(self) -> Field {\n        // let pub_key = array_helpers::u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n         let pub_key = u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n\nfn u8_32_to_u8_64(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\nunconstrained\nfn u8_32_to_u8_64_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\n/// @dev this method is used to convert a u8 array to a u160 (which is not supported by Noir, so it's represented as a Field)\n/// @dev will throw on Field overflow\nfn u8_to_u160(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nunconstrained\nfn u8_to_u160_unconstrained(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nfn u8_to_eth_address(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\nunconstrained\nfn u8_to_eth_address_unconstrained(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\nfn split_u8_64(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\nunconstrained\nfn split_u8_64_unconstrained(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}","path":"/Users/jack-sw/nargo/github.com/porco-rosso-j/ecrecover-noir/main/src/secp256k1.nr"}},"names":["main"]}