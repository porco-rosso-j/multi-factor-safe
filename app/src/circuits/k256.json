{
    "noir_version": "0.30.0+af57471035e4fa7eaffa71693219df6d029dbcde",
    "hash": 10062170924744704299,
    "abi": {
        "parameters": [
            {
                "name": "owner_hash",
                "type": {
                    "kind": "field"
                },
                "visibility": "public"
            },
            {
                "name": "domain_separator",
                "type": {
                    "kind": "array",
                    "length": 32,
                    "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                    }
                },
                "visibility": "public"
            },
            {
                "name": "hashed_message",
                "type": {
                    "kind": "array",
                    "length": 32,
                    "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                    }
                },
                "visibility": "public"
            },
            {
                "name": "pub_key",
                "type": {
                    "kind": "array",
                    "length": 64,
                    "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                    }
                },
                "visibility": "private"
            },
            {
                "name": "signature",
                "type": {
                    "kind": "array",
                    "length": 64,
                    "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                    }
                },
                "visibility": "private"
            }
        ],
        "param_witnesses": {
            "domain_separator": [
                {
                    "start": 1,
                    "end": 33
                }
            ],
            "hashed_message": [
                {
                    "start": 33,
                    "end": 65
                }
            ],
            "owner_hash": [
                {
                    "start": 0,
                    "end": 1
                }
            ],
            "pub_key": [
                {
                    "start": 65,
                    "end": 129
                }
            ],
            "signature": [
                {
                    "start": 129,
                    "end": 193
                }
            ]
        },
        "return_type": null,
        "return_witnesses": [],
        "error_types": {}
    },
    "bytecode": "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",
    "debug_symbols": "zZ3hjlTHEUbfZX8ja+r7qrureZXIirCNIyS0WAZHihDvnsHsDo59b3Zz4rb63y7c0zTLqZLmwA4f7354/d0v//j7m/sf372/e/m3j3dv333/6sObd/fXzz7exdSvP/j+p1f3nz9//+HVzx/uXupSL+5e3/9w/ajNTy/ufnzz9vXdy+yfXvzh0RHx8OjI9vXR+vTti+vpXnp6Lj29LT29Lz19LD29lp4+F56uy2Xp6bH0dC093UtPz6Wnt6Wn96Wnj6Wn19LTl85qLJ3VWDqrsXRWY+msxtJZjaWzGktnNZbOaiyd1Vg6q1o6q1o6q1o6q1o6q1o6q1o6q1o6q1o6q1o6q1o6q146q146q146q146q146q146q146q146q146q146q7l0VnPprObSWc2ls5pLZzWXzmoundVcOqu5dFZz6ay2pbPals5qWzqrbemstqWz2pbOals6q+14Vms8IJ7tv5+udrvI/M1FxsGjEf3x2bj+wn+4Sq26yq+nz//zdMftUY8nfqOpxy955PDvf6P9ss9VYp+raJ+reJ+r5D5Xaftcpe9zlbHPVWqfq+yzbcc+23bss23HPtt27LNtxz7bduyzbcc+23bss23HPtt27LNta59tW/ts29pn29Y+27b22ba1z7atfbZt7bNta59tW/ts27nPtp37bNu5z7ad+2zbuc+2nfts27nPtp37bNu5z7ad22xbX7bZtr5ss2192Wbb+rLNtvVlm23ryzbb1pdttq0v22xbX7bZtr7ss21jn20b+2zb2Gfbxj7bNvbZtrHPto19tm3ss21jn20b+2xb7bNttc+21T7bVvtsW/2V27Zd8vEq7bcPP1yl7XOVw23b45Hp+cRVIsbjXULx9WHNL+ePxefX4vPn2vOPv2fhTzw/Fp+vxed78fm5+Py2+PzF83v8HQxDj/9mcbT/OP/bz9/orm/iODrluFweuOuH8btd9AUMCoqCpmBSsFGwU3BQsCg4IRjUnKDmBDUnqDlBzQlqTlBzgpoT1Jyg5oiaI2qOqDmi5oiaI2qOqDmi5oiaI2qOqTmm5piaY2qOqTmm5piaY2qOqTmm5iQ1J6k5Sc1Jak5Sc5Kak9ScpOYkNSepOY2a06g5jZrTqDmNmtOoOY2a06g5jZrTqDmdmtOpOZ2a06k5nZrTqTmdmtOpOZ2a06k5g5ozqDmDmjOoOYOaM6g5g5ozqDmDmjOoOUXNKWpOUXOKmlPUnKLmFDWnqDlFzSlqzqTmTGrOpOZMas6k5kxqzqTmTGrOpOZMaI5oQxZtyKINWbQhizZk0YYs2pBFG7JoQxZtyKINWbQhizZk0YYs2pBFG7JoQxZtyKINWbQhizZk0YYs2pBFG7JoQxZtyKINWbQhizZk0YYs2pBFG7JoQxZtyKINWbQhizZk0YYs2pBFG7JoQxZtyDpryJ43MC+HoCmYFGwU7BQcFCwKTgieNeSnwaAgNadRcxo1p1FzGjWnUXMaNadRczo1p1NzOjWnU3M6NadTczo1p1NzOjWnU3MGNWdQcwY1Z1BzBjVnUHMGNWdQcwY1Z1BzippT1Jyi5hQ1p6g5Rc0pak5Rc4qaU9ScSc2Z1JxJzZnUnEnNmdScSc2Z1JxJzZnQHF8uFAwKioKmYFKwUbBTcFCwKEjNCWpOUHOCmhPUnKDmBDUnqDlBzQlqTlBzRM0RNUfUHFFzRM0RNUfUHFFzRM0RNcfUHFNzTM0xNcfUHFNzTM0xNcfUHFNzkpqT1BzakE0bsmlDNm3Ipg3ZtCGbNmTThmzakE0bsmlDNm3Ipg3ZtCGbNmTThmzakE0bsmlDNm3Ipg3ZtCGbNmTThmzakE0bsmlDNm3Ipg3ZtCGbNmTThmzakE0bsmlDNm3Ipg3ZtCGbNmTThmzakH0WZnvewN4PwQHBk0xatzcAyQodgkFBUdAUTAo2CnYKDgoWBScD86ySPaVcnlWyp8GgoChoCp5s8qobOPMQbBTsFBwULApOCJ5Vstu7kVzPaIdgUFAUNAWTgo2CnYKDgkXBCUFTc0zNMTXH1BxTc0zNMTXH1BxTc0zNSWpOUnOSmpPUnKTmJDUnqTlJzUlqTlJzGjWnUXMaNadRcxo1p1FzGjWnUXMaNadRczo1p1NzOjWnU3NOKlnF7TVy6RhsFOwUHBQsCp68KIv2FTx83XFSyZ4BBgVFQVMwKQhfzufoFBwULArSl/N1oWBQUBQ0BZOC1Jyi5hQ1p6g5Rc2hCTFpQkyaEJMmxKQJMWlCTJoQkybEpAkxaUJslwsFg4KioCmYFGwU7BQcFATmqM1vjjeHr3+d9cBdP+xHXEBOkDPkEnINch1yA3IFucm4k7eIfg4YFBQFTcGkYKNgp+CgYFGQmhPUnKDmBDUnqDlBzQlqTlBzgpoT1Jyg5oiaI2qOqDmi5oiaI2qOqDmi5oiaI2qOqTmm5piaY2qOqTmm5piaY2qOqTmm5iQ1J6k5Sc1Jak5Sc5Kak9ScpOYkNSepOY2a06g5jZrTqDmNmtOoOY2a06g5jZrTqDmdmtOpOZ2a06k5nZrTqTmdmtOpOZ2a06k5g5ozqDmDmjOoOYOaM6g5g5ozqDmDmjOoOUXNKWpOUXOKmlPUnKLmFDWnqDlFzSlqDk3HQdtx0HgctB4HzcdB+3HQgBy0IAdNyEEbsmhDFm3Iog1ZtCGLNmTRhizakEUbsmhDFm3Iog1ZtCGLNmTRhizakEUbsmhDFm3Iog1ZtCGLNmTRhizakEUbsmhDFm3Iog1ZtCGLNmTRhizakEUbsmhDFm3Iog1ZtCGLNmTRhizakEUbsmhDFm3Iog1ZtCGLNmTRhizakEUbsmhDFm3Iog1ZtCGLNmTRhizakEUbsmhDFm3Iog1ZtCGLNmTRhizakEUbsmhDFm3Iog1ZtCGLNmTRhizakEUbsmhDFm3Iog1ZtCGLNmTRhizakEUbsmhDFm3Iog1ZtCGLNmTRhizakEUbsmhDFm3Iog1ZtCGLNmTRhizakEUbsmhDFm3Iog1ZtCGbNmTThmzakE0bsmlDNm3Ipg3ZtCGbNmTThmzakE0bsmlDNm3Ipg3ZtCGbNmTThmzakE0bsmlDNm3Ipg3ZtCGbNmTThmzakE0bsmlDNm3Ipg3ZtCGbNmTThmzakE0bsmlDNm3Ipg3ZtCGbNmTThmzakE0bsmlDNm3Ipg3ZtCGbNmTThmzakE0bsmlDNm3Ipg3ZtCGbNmTThmzakE0b8sn7Ll9X0eP/UHr9UIdgQvCkPWabN7DHIRgUPLnq0A2sOgQbBTsFBwULgiex6+mv6knsegbYKTgoWBQ8Hqus+PpVHUfgSex6BhgUFAVNwRNz5ldwzkOwUbBTcFCwKDgZmCex68lBzpPY9QxQFDQFk4KNgp2Cg4JFwQnBoOYENSeoOUHNCWpOUHOCmhPUnKDmBDVH1BxRc0TNETVH1BxRc0TNETVH1BxRc0zNMTXH1BxTc0zNMTXH1BxTc0zNOUlPT74MPHnf5eeApmBSsFHw5M9R4wa6HYKDgkXBCcGT9PQMMCh4Yk74BioPQVMwKdgo2Ck4KFgUnBA8+eeLzwCDgtScTs3p1JxOzenUnE7N6dScTs0Z1JxBzRnUnEHNGdScQc0Z1JxBzRnUnEHNKWpOUXOKmlPUnKLmFDWnqDlFzSlqTlFz5v9szvWTf776+c2r796+fn9FPv/cL/fff3jz7v7h0w//+unLz1yf/Tc=",
    "file_map": {
        "29": {
            "source": "mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, N> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n",
            "path": "std/hash.nr"
        },
        "46": {
            "source": "use dep::std;\nuse dep::ecrecover;\n\nfn main(\n    owner_hash: pub Field,\n    domain_separator: pub [u8;32],\n    hashed_message: pub [u8; 32],\n    pub_key: [u8; 64], \n    signature: [u8; 64], \n) {\n    let key = ecrecover::secp256k1::PubKey::from_unified(pub_key);\n\n    let recovered_addr = ecrecover::ecrecover(\n        key.pub_x, \n        key.pub_y,\n        signature,\n        hashed_message\n    );\n\n    // std::println(recovered_addr);\n\n    let mut input: [Field; 33] = [0; 33];\n    input[0] = recovered_addr;\n    for i in 0..32 {\n        input[i + 1] = domain_separator[i] as Field;\n    }\n\n    let computed_hash = std::hash::pedersen_hash(input);\n    // std::println(computed_hash);\n    // std::println(owner_hash);\n\n    assert(computed_hash == owner_hash);\n}\n\n#[test]\nfn test_main() {\n\n  let hashed_message = [\n  162,  11, 221, 82, 101,  38, 145, 153,\n  143, 140, 164, 97, 148, 164,  55, 133,\n   17,  93, 198, 63, 125, 169, 147,  53,\n  229, 221,  91, 27,   2, 153, 104, 166\n  ];\n\n  // slice(1, 65)\n  let pub_key = [\n   30, 208, 241, 215, 103,  94, 254, 117,  70, 152,\n   81, 205,  82, 148,   1, 169, 164,  67,  60,   5,  20,\n  174, 250, 221, 242,  79,   1,  65, 210,  85, 102, 168,\n  120, 138,  73, 199,  27, 230, 199, 139,  88,  30, 223,\n  222, 101,  80, 215, 183, 206, 127,  56, 111,  54,  82,\n   44, 173,  86,  64, 143, 202,   3, 123,  35,   7\n  ];\n\n//   let owner_hash = 0x137ad2247d8e089ca5dc03f9a70e5bc68392ac2916495968a80c35582c1a3c37;\n  let owner_hash = 0x0ee869caf0f6187c861a3a319899bb97d0477722d2bce78c99012dc1ae6d729e;\n  let domain_separator: [u8;32] = [\n    104, 180, 171,  96, 220, 243, 144,  50,\n    0, 243, 196,  36, 122, 173, 193, 146,\n    6, 179,  23,  80, 130, 243,  86, 120,\n    244, 174, 100, 147, 213,  51, 243, 148\n  ]; \n\n    \n  let signature = [\n   25,  83, 188,  15,  31, 138, 125,  61,  75, 210,  21,\n  189, 152,   0,  92, 131, 218, 172,  94, 192, 193, 134,\n  157, 109, 196, 152, 210, 247, 229, 218,  78, 217,  93,\n  135, 208,  54, 203, 151, 127,  76, 197, 189,  92,   5,\n  141, 185,  59, 102, 220, 138, 219, 235,  91, 108, 193,\n  227,  61, 200,  57, 163, 137,  92,  36, 209\n  ];\n\n  main(owner_hash, domain_separator,hashed_message, pub_key, signature );\n}\n\n// fn main(\n//     owner_address: pub Field,\n//     owner_hash: pub Field,\n//     salt: pub [u8;32], \n//     commitment_hash: pub [u8;32]\n// ) {\n//     let copmputed_innter_owner_hash = std::hash::pedersen_hash([owner_address]);\n//     std::println(copmputed_innter_owner_hash);\n\n//     // todo: rename input to inner_owner_hash_with_salt\n//     let mut input: [Field; 33] = [0; 33];\n//     input[0] = copmputed_innter_owner_hash;\n//     for i in 0..32 {\n//         input[i + 1] = salt[i] as Field;    \n//     }\n\n//     let copmputed_owner_hash = std::hash::pedersen_hash(input);\n//     std::println(copmputed_owner_hash);\n//     assert(copmputed_owner_hash == owner_hash);\n// }\n\n// #[test]\n// fn test_main() {\n//     let owner_address: Field = 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266; //\n//     let owner_hash: Field = 0x1701ab64077e0b7cd524be455316457954d1bdf8297e8e2fb832a02f168dddc0;\n    \n//     // salt = chain id for test\n//     let salt: [u8;32] = [\n//         243, 159, 214, 229,  26, 173, 136, 246,\n//         244, 206, 106, 184, 130, 114, 121, 207,\n//         255, 185,  34, 102,   0,   0, 122, 105,\n//         0,   0,   0,   0,   0,   0,   0,   0\n//     ]; \n\n//     let commitment_hash: [u8;32] = [\n//         135, 197,  57, 225, 58, 211, 248,  26,\n//         224,  27, 100,  27, 55, 170,  29, 241,\n//         169, 191,  63, 118, 94,   8, 209, 198,\n//         157, 254, 249,  95, 78,  14,  34,  39\n//     ];\n    \n//     main(owner_address, owner_hash, salt, commitment_hash);\n\n//     // copmputed_owner_hash: \n// }\n\n// #[test]\n// fn test_main2() {\n//     let owner_address: Field = 0x91A399E2F7B768e627f1f7Aff2Df88bA73813911; //\n//     let owner_hash: Field = 0x1701ab64077e0b7cd524be455316457954d1bdf8297e8e2fb832a02f168dddc0;\n    \n//     // salt = chain id for test\n//     let salt: [u8;32] = [\n//         243, 159, 214, 229,  26, 173, 136, 246,\n//         244, 206, 106, 184, 130, 114, 121, 207,\n//         255, 185,  34, 102,   0,   0, 122, 105,\n//         0,   0,   0,   0,   0,   0,   0,   0\n//     ]; \n\n//     let commitment_hash: [u8;32] = [\n//         135, 197,  57, 225, 58, 211, 248,  26,\n//         224,  27, 100,  27, 55, 170,  29, 241,\n//         169, 191,  63, 118, 94,   8, 209, 198,\n      \n//         157, 254, 249,  95, 78,  14,  34,  39                 \n//     ];\n\n//     std::println(\"hey\");\n// }",
            "path": "/Users/jack-sw/Codes/brussels/mfa-multisig/circuits/k256/src/main.nr"
        },
        "47": {
            "source": "use dep::std;\n\nmod secp256k1;\n\nfn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> pub Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [\n        131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117\n    ];\n    let pub_key_y = [\n        53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165\n    ];\n    let signature = [\n        57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177\n    ];\n    let hashed_message = [\n        13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102\n    ];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n",
            "path": "/Users/jack-sw/nargo/github.com/porco-rosso-j/ecrecover-noir/main/src/lib.nr"
        },
        "48": {
            "source": "use dep::std;\n\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nunconstrained\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        // let (key_x, key_y) = array_helpers::split_u8_64_unconstrained(pub_key);\n         let (key_x, key_y) = split_u8_64_unconstrained(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    fn to_eth_address(self) -> Field {\n        // let pub_key = array_helpers::u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n         let pub_key = u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n\nfn u8_32_to_u8_64(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\nunconstrained\nfn u8_32_to_u8_64_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\n/// @dev this method is used to convert a u8 array to a u160 (which is not supported by Noir, so it's represented as a Field)\n/// @dev will throw on Field overflow\nfn u8_to_u160(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nunconstrained\nfn u8_to_u160_unconstrained(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nfn u8_to_eth_address(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\nunconstrained\nfn u8_to_eth_address_unconstrained(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\nfn split_u8_64(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\nunconstrained\nfn split_u8_64_unconstrained(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}",
            "path": "/Users/jack-sw/nargo/github.com/porco-rosso-j/ecrecover-noir/main/src/secp256k1.nr"
        }
    },
    "names": [
        "main"
    ]
}